예를 들어, 현수의 책상에 14, 17, 14개가 각각 바구니에 담겨 있다면 현수는 사과(14개) 또는 귤(14개) 중 하나를 가져간다.

즉, 현수는 14개의 과일을 가져가는 것이다.

모든 학생은 딱 한 번 바구니의 과일 한 개를 다른 학생과 교환할 수 있는 기회가 있다.

교환하는 규칙은 다음과 같다.

1) 1번 학생부터 번호 순으로 교환을 할 건지 결정한다.

2) 교환을 하는 양쪽 학생이 서로 이득이 되면 무조건 교환을 한다. 즉, 양쪽이 모두 가져가는 과일의 개수가 원래 가져가려고 했던 것보다 증가한다면 교환을 무조건 한다.

3) 교환을 할 때는 A바구니는 사과만, B바구니에는 배만, C바구니에는 귤만 담아야 한다.

4) 교환 가능한 학생이 여러명일 경우 가장 번호가 작은 학생과 교환한다.

5) 서로가 이득이 생기는 경우가 존재하지 않으면 교환하지 않는 학생도 있다.

<img width="314" alt="스크린샷 2024-03-27 오후 2 46 40" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/86195732-ae3f-4f6c-bd76-e35eb0455ae4">

매개변수 fruit 에 1번 학생부터 n번 학생까지의 A, B, C 세 바구니에 들어있는 과일의 개수 정보가 주어지면 모든 교환이 끝난 후 모든 학생이 가져가는 과일의 총 개수를 반환하는 프로 그램을 작성하라.

### 입출력 예

---
<img width="800" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-03-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203 02 02" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/f61b4b72-d753-4e5a-8320-2cb71b514ebc">


### 입력예제 1 설명

---

1번 학생은 3번 학생과 사과를 받고 배를 주는 교환을 해서 1번 학생은 [11, 19, 30], 3번 학생은 [19, 13, 15]로 변한다.

즉, 1번 학생은 최소값이 10에서 11로 증가하고, 3번 학생은 최 소값이 12에서 13으로 증가한다.

2번 학생은 4번 학생과 사과를 받고 귤을 주는 교환하여 2 번 학생은 [13, 15, 19], 4번 학생은 [14, 20, 11]이 된다.

5번 학생은 교환을 할 학생이 없다.

모든 학생이 가져가는 과일의 총 개수는 11 + 13 + 13 + 11 + 10 = 58 이다.

### 제한사항

---

- fruit 의 길이는 10,000을 넘지 않습니다. 즉 n은 10,000을 넘지 않는다.
- 각 바구니에 담기는 과일이 개수는 0부터 50개 까지입니다. (0 <= 과일개수 <= 50)

### 문제 접근

---

해당 문제는 문제에서 요구하는 것을 정확하게 파악하고 코드를 설계하고 구현하는것을 물어보는 문제인것 같다.

문제를 이해하는데 상당히 많은 시간이 걸렸지만 문제에서 핵심은 다음과 같다.

**2) 교환을 하는 양쪽 학생이 서로 이득이 되면 무조건 교환을 한다. 즉, 양쪽이 모두 가져가는 과일의 개수가 원래 가져가려고 했던 것보다 증가한다면 교환을 무조건 한다.**

**5) 서로가 이득이 생기는 경우가 존재하지 않으면 교환하지 않는 학생도 있다.**

2번에서 이득이 나면 무조건 교환한다고 했으므로 서로 교환을 했을때 이득이 나는 경우를 생각해봐야한다.

문제에서 요구하는 조건을 바탕으로 정리해보면 아래와 같다.

1. 각 학생의 과일 갯수의 최솟값이 유일해야한다.

    <aside>
    💡 만약 어떤 학생의 각 과일 갯수가 10, 15, 10처럼 과일 갯수의 최솟값이 유일하지 않을때, 이 학생은 과일을 교환하기전에 10개를 가져가는 상태다.

   그리고 조건에 따라 과일을 교환하면 11, 15, 10 또는 10, 15, 11이 될수있다.

   → **과일을 교환했음에도 가져가는 과일의 갯수는 10개로 변함이 없으므로 이득이 발생하지 않는다. 따라서, 5)의 조건에따라 교환을 진행하지 않는다.**

    </aside>

2. 서로 교환하려고 하는 두 학생의 최소갯수의 과일의 종류가 서로 달라야한다.

    <aside>
    💡 만약에 A학생의 최소갯수의 과일 종류가 **사과**이고 10개 가지고있고, B학생의 최소갯수의 과일 종류가 **사과**이면서 15개 가지고 있다고 가정하자.

   그럼 문제의 조건에따라 **최소갯수의 과일만 서로 교환할 수 있으므로, 사과끼리 하나씩 주고받으면 교환을 진행했음에도 사과의 갯수에는 변함이 없다.**

   → 과일을 교환했음에도 동일한 과일을 교환했기 때문에, 이득이 발생하지 않는다. 따라서, 5)의 조건에 따라 교환을 진행하지 않는다.

    </aside>

3. 교환했을때 1개 증가한 과일의 갯수가 그대로 최소 과일 갯수 상태를 유지해야한다.

    <aside>
    💡 A학생이 10, 20, 30 만큼 과일을 가지고 있고 B학생이 20, 10, 30 일때 문제의 조건에 따라 과일을 교환하면 A학생은 11, 19, 30  B학생은 19, 11, 30 가 된다.

   → **교환을 진행하고나서 A학생과 B학생의 최소 갯수의 과일 종류가 교환을 진행하기 전과 동일하다. 그리고 가져갈수 있는 과일의 갯수가 1개 증가했으므로 이득이 발생했다. 따라서 2) 조건에따라, 교환을 진행한다.**

    </aside>


문제를 읽고 위와 같이 생각해내는게 정말 어려운 문제인것 같다. 해당 문제를 완벽하게 이해하고 비슷한 다른 문제를 많이 풀어봐야 해당 문제 유형에 익숙해질것 같다.

### 체크포인트

---

- **이미 교환을 진행한 학생에 대해서 탐색을 진행하지 않는다.**

    ```java
    문제에서 주어진 조건에 따라 모든 학생은 딱 한번 바구니의 과일 한개를 다른 학생과 교환할 수 있다고 했으므로 visited 배열을 활용하여 교환을 진행하기전 이미 교환을 진행한 학생인지 확인하고 탐색을 진행한다.
    ```

- **이득이 발생하는 경우에만 교환 진행**

    ```java
    1. 각 학생의 과일 갯수의 최솟값이 유일해야한다.
    
    2. 서로 교환하려고 하는 두 학생의 최소갯수의 과일의 종류가 서로 달라야한다.
    
    3. 교환했을때 1개 증가한 과일의 갯수가 그대로 최소 과일 갯수 상태를 유지해야한다. 
    
    위의 세가지 조건을 만족하는 경우에만 탐색을 진행하여 교환을 하도록하자.
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 학생 한명을 선택하고 해당 학생의 교환 진행 여부와 해당 학생의 최소 갯수 과일의 종류가 유일한지 확인

    ```java
    // 첫번째 학생 선택
    for (int i = 0; i < n; i++) {
        // 이미 한번 교환을 한 학생이고 해당 학생의 최소 갯수 과일의 종류가 유일하지 않다면
        if (visited[i] || !isMinUnique(fruit[i])) {
            // 다음 탐색 진행
            continue;
        }
    ```

2. 또다른 학생을 선택하고 해당 학생의 교환 진행 여부와 해당 학생의 최소 갯수 과일의 종류가 유일한지 확인

    ```java
     // 두번째 학생 선택
    for (int j = i + 1; j < n; j++) {
        // 이미 한번 교환을 한 학생이고 해당 학생의 최소 갯수 과일의 종류가 유일하지 않다면
        if (visited[j] || !isMinUnique(fruit[j])) {
            // 다음 탐색 진행
            continue;
        }
    ```

3. 각 학생의 최소 갯수 과일의 종류를 저장.

    ```java
     // 최소 갯수의 과일 종류(인덱스) 저장
    int fruitA = getMinValIdx(fruit[i]);
    int fruitB = getMinValIdx(fruit[j]);
    ```

4. 각 학생의 최소 갯수의 과일 종류가 다르고 서로 상대방에게 나눠 줘야하는 과일의 갯수가 최소 한개 이상이여야 교환을 진행할 수 있으므로 해당 조건을 만족하는지 체크

    ```java
     if (fruitA != fruitB && fruit[i][fruitB] > 0 && fruit[j][fruitA] > 0) {
    ```

5. 서로 과일을 받고나서 남은 과일의 갯수와 상대방에게 나누어주고 남은 과일의 갯수를 비교했을때 같거나 작아야 교환을 진행했을때 이득이 발생하므로 해당 조건을 만족하는지 체크

    ```java
    if (fruit[i][fruitA] + 1 <= fruit[i][fruitB] - 1 && fruit[j][fruitB] + 1 <= fruit[j][fruitA] - 1) {
    ```

6.  번째 학생과 j 번째 학생이 이득이 발생하는 조건에 따라 과일을 교환하고 i번째 학생과 j번째 학생의 과일 교환 여부를 체크한다.

    그리고 교환 가능한 학생이 여러명일때 번호가 가장 작은 학생부터 교환을 우선으로 진행한다 했으므로 남은 학생들과 교환이 가능하더라도 이미 교환을 한번 진행했으면 해당 학생들에 대한 탐색 종료.

    ```java
    // i 학생이 A 과일을 한개 받음
    fruit[i][fruitA]++;
    // i 학생이 B 과일을 한개 나누어줌
    fruit[i][fruitB]--;
    // j 학생이 B 과일을 한개 받음
    fruit[j][fruitB]++;
    // j 학생이 A 과일을 한개 나누어줌
    fruit[j][fruitA]--;
    // 교환을 진행했으므로 i, j 학생 교환 여부 체크
    visited[i] = true;
    visited[j] = true;
    //교환을 이미 한번 진행했으면 해당 학생들에 대한 탐색 종료. 
    break;
    ```

7. 각 학생은 보유한 과일바구니에서 최소 갯수의 과일만 가져갈 수 있으므로, 문제에서 요구하는 형식대로 정답 출력

    ```java
    int answer = 0;
    for (int[] val : fruit) {
        answer += getMinVal(val);
    }
    return answer;
    ```


### 코드

---

```java
// 각 학생의 과일중에서 최소 갯수 과일의 갯수를 리턴 
static int getMinVal(int[] fruit) {
    int minVal = Integer.MAX_VALUE;
    for (int val : fruit) {
        minVal = Math.min(minVal, val);
    }
    return minVal;
}

// 각 학생의 과일 중에서 최소 갯수 과일의 종류(인덱스) 리턴
static int getMinValIdx(int[] fruit) {
    int minVal = getMinVal(fruit);
    for (int i = 0; i < fruit.length; i++) {
        if (minVal == fruit[i]) {
            return i;
        }
    }
    return -1;
}

// 각 학생의 과일 중에서 최소갯수의 과일 종류가 유일한지를 리턴
static boolean isMinUnique(int[] fruit) {
    int cnt = 0;
    int minVal = getMinVal(fruit);
    for (int val : fruit) {
        if (val == minVal) {
            cnt++;
            if (cnt > 1) {
                return false;
            }
        }
    }
    return true;
}

static int solution(int[][] fruit) {
    int n = fruit.length;
		
    // 각 학생의 교환여부 체크 배열
    boolean[] visited = new boolean[n];
    // 첫번째 학생 선택
    for (int i = 0; i < n; i++) {
        // 이미 한번 교환을 한 학생이고 해당 학생의 최소 갯수 과일의 종류가 유일하지 않다면
        if (visited[i] || !isMinUnique(fruit[i])) {
             // 다음 탐색 진행
            continue;
        }
        // 두번째 학생 선택
        for (int j = i + 1; j < n; j++) {
            // 이미 한번 교환을 한 학생이고 해당 학생의 최소 갯수 과일의 종류가 유일하지 않다면
            if (visited[j] || !isMinUnique(fruit[j])) {
                // 다음 탐색 진행
                continue;
            }
            // 최소 갯수의 과일 종류(인덱스) 저장
            int fruitA = getMinValIdx(fruit[i]);
            int fruitB = getMinValIdx(fruit[j]);
            // 최소 갯수의 과일 종류가 다르고 서로 상대방에게 나눠 줘야하는 과일의 갯수가 최소 한개 이상인지 체크 
            if (fruitA != fruitB && fruit[i][fruitB] > 0 && fruit[j][fruitA] > 0) {
                // 서로 과일을 받고나서 남은 과일의 갯수와 상대방에게 나누어주고 남은 과일의 갯수를 비교했을때 같거나 작아야 교환을 진행한 의미가 있으므로 체크
                if (fruit[i][fruitA] + 1 <= fruit[i][fruitB] - 1 && fruit[j][fruitB] + 1 <= fruit[j][fruitA] - 1) {
                    // i 학생이 A 과일을 한개 받음
                    fruit[i][fruitA]++;
                    // i 학생이 B 과일을 한개 나누어줌
                    fruit[i][fruitB]--;
                    // j 학생이 B 과일을 한개 받음
                    fruit[j][fruitB]++;
                    // j 학생이 A 과일을 한개 나누어줌
                    fruit[j][fruitA]--;
                    // 교환을 진행했으므로 i, j 학생 교환 여부 체크
                    visited[i] = true;
                    visited[j] = true;
                    // 교환 가능한 학생이 여러명일때 번호가 가장 작은 학생부터 교환을 우선으로 진행한다 했으므로 남은 학생들과 교환이 가능하더라도 교환을 이미 한번 진행했으면 해당 학생들에 대한 탐색 종료. 
                    break;
                }
            }
        }
    }
    // 각 학생은 보유한 과일바구니에서 최소 갯수의 과일만 가져갈 수 있으므로,
    // 문제에서 요구하는 형식대로 정답 출력
    int answer = 0;
    for (int[] val : fruit) {
        answer += getMinVal(val);
    }
    
    return answer;
}
```