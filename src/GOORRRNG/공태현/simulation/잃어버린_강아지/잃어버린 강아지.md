### 문제

---

현수는 농사지을 땅을 찾아 강아지를 데리고 산으로 들로 땅을 찾아 다니고 있었다.

숲속에서 낮잠을 자던 현수는 강아지가 도망가버려 강아지를 잃게 되었다.

강아지가 어디로 갔는지 모르는 현수는 강아지를 찾아 나섰다.

다행히 강아지에게 위치 추적기가 달려 있어 핸드폰 실시 간 위성지도로 현수의 위치와 강아지의 위치, 그리고 근처의 지도를 현수는 알 수 있다.

지도의 크기는 항상 10*10이며, 각각의 칸에는 각각 나무, 빈칸, 강아지, 그리고 현수가 있을 수 있다.

지도는 다음과 같이 주어진다.

0-빈칸, 1-나무, 2-현수, 3-강아지 강아지와 현수는 항상 고정된 방법으로 지도를 다닌다.

먼저 북쪽(지도에서 위쪽)으로 출발하되, 계속 한쪽방향으로 가다가 나무나 지도의 끝에 이르면 90도 시계방향으로 회전하게 된다.

한 칸을 이동하거나, 방향을 회전할 때에는 1분이 소요된다.

만약 이동, 또는 회전을 한 후 현수와 강아지가 같은 칸에 있게 되면 현수가 강아지를 찾게 된다.

현수와 강아지가 있는 숲의 지도정보가 board에 주어지면 몇 분 후에 현수가 강아지를 찾 을 수 있는지 구하는 프로그램을 작성하라. 10,000분 후에도 찾을 수 없으면 0을 반환한다.

### 입출력 예

---
<img width="435" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-03-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204 18 31" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/16caf1b4-a5b6-4242-b8f9-605f92c38aaa">

### 문제 접근

---

해당 문제는 청소 문제와 같이 얼핏 보면 최단 거리나 경로 탐색이 문제처럼 DFS, BFS를 활용해야 할것 같다.

하지만 단순하게 현수와 강아지를 움직이고 몇분후에 만나는지를 출력하는 문제이므로 **dx dy technic**만 활용하여 문제를 풀면된다.

특히, **갈수 없는 위치를 탐색하게 된다면 방문하지 않고 회전** 된다는것만 유의해서 문제를 풀면 크게 어렵지 않게 문제를 풀 수 있을것 같다.

또한, 현수만 회전하는것이 아닌 강아지도 회전하는 경우를 각각 처리해줘야 하는것 또한 유의해야한다.

### 체크포인트

---

- **현수와 강아지가 회전하는 경우를 각각 처리**

    ```java
    // 현수의 방향과 강아지의 방향값 생성
    int dir1 = 0, dir2 = 0;
    // 현수와 강아지가 각각 회전했는지를 표시하기 위한 변수 생성
    boolean isRotate1 = false, isRotate2 = false;
    
    // 현수가 회전하는 경우
    dir1 = (dir1 + 1) % 4;
    isRotate1 = true;
    
    // 강아지가 회전하는 경우
    dir2 = (dir2 + 1) % 4;
    isRotate2 = true;
        
    위의 코드처럼 처음 방향을 문제에서 요구하는것 처럼 0(북쪽)으로 선언하고 현수가 회전하는 경우와 강아지가 회전하는 경우를 각각 처리해준다. 
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 강아지와 현수의 탐색 방향을 구현하기 위한 위한 dir1, dir2 변수와 각각의 방향대로 방향대로 탐색하기 위한 dx dy 생성하고 현수의 위치값을 저장하기 위한 x1, y1 강아지의 위치값을 저장하기 위한 x2, y2 변수를 생성

    ```java
    int dir1 = 0, dir2 = 0;
    int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
    int x1 = 0, y1 = 0;
    int x2 = 0, y2 = 0;
    ```

2. 강아지와 현수의 시작위치를 탐색하여 각각의 시작 좌표를 초기화

    ```java
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
    		    // 현수의 시작위치
            if (board[i][j] == 2) {
                x1 = i;
                y1 = j;
            }
            // 강아지의 시작위치
            if (board[i][j] == 3) {
                x2 = i;
                y2 = j;
            }
        }
    }
    ```

3. 탐색을 시작하면서 경과 시간 1분 증가

    ```java
    int time = 0;
    while (time < 10000) {
        // 1분 경과
        time++;
    ```

4. 각각 회전했는지에 대한 여부를 체크하는 변수생성과 새롭게 탐색하려는 위치값을 현재 각각의 방향에 따라서 초기화

    ```java
    // 현수와 강아지가 회전했는지를 표시하기 위한 변수 생성
    boolean isRotate1 = false, isRotate2 = false;
    // 현수가 새롭게 탐색하는 위치 값을 저장
    int nx1 = x1 + dx[dir1];
    int ny1 = y1 + dy[dir1];
    // 강아지가 새롭게 탐색하는 위치 값을 저장
    int nx2 = x2 + dx[dir2];
    int ny2 = y2 + dy[dir2];
    ```

5. 회전해야는 위치라면 각각 회전

    ```java
    // 현수가 회전해야하는지 검증
    if(0 > nx1 || nx1 >= 10 || 0 > ny1 || ny1 >= 10 || board[nx1][ny1] == 1) {
        dir1 = (dir1 + 1) % 4;
        isRotate1 =true;
    }
    // 강아지가 회전회야하는지 검증
    if(0 > nx2 || nx2 >= 10 || 0 > ny2 || ny2 >= 10 || board[nx2][ny2] == 1) {
        dir2 = (dir2 + 1) % 4;
        isRotate2 =true;
    }
    ```

6. 회전하지 않았다면 현재 방향대로 다른 위치로 탐색 가능하다는 의미이므로 회전했는지를 검증하고 회전하지 않았다면 새로운 위치 탐색

    ```java
    // 현수가 회전했는지 확인
    if (!isRotate1) {
    		// 회전하지 않았다면 현재 위치 값을 새로운 위치값으로 업데이트
        x1 = nx1;
        y1 = ny1;
    }
    // 강아지가 회전했는지 확인
    if (!isRotate2) {
    		// 회전하지 않았다면 현재 위치 값을 새로운 위치값으로 업데이트
        x2 = nx2;
        y2 = ny2;
    }
    ```

7. 각각 회전했거나 새로운 위치로 방문한 후에 현수와 강아지의 위치가 같다면 현재 경과 시간값을 리턴하고 탐색종료

    ```java
    if (x1 == x2 && y1 == y2) {
        return time;
    }
    ```

8. 탐색이 종료되었음에도, 강아지와 현수가 만나지 못한다면 문제에서 요구하는대로 0 리턴

    ```java
    return 0;
    ```


**`dx dy technic`** 활용

### 코드

---

```java
 static int solution(int[][] board) {
    int dir1 = 0, dir2 = 0;
    int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
    int x1 = 0, y1 = 0;
    int x2 = 0, y2 = 0;

    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (board[i][j] == 2) {
                x1 = i;
                y1 = j;
            }
            if (board[i][j] == 3) {
                x2 = i;
                y2 = j;
            }
        }
    }
    
    int time = 0;
    while (time < 10000) {
        time++;
        boolean isRotate1 = false, isRotate2 = false;
        int nx1 = x1 + dx[dir1];
        int ny1 = y1 + dy[dir1];
        int nx2 = x2 + dx[dir2];
        int ny2 = y2 + dy[dir2];

        if (0 > nx1 || nx1 >= 10 || 0 > ny1 || ny1 >= 10 || board[nx1][ny1] == 1) {
            dir1 = (dir1 + 1) % 4;
            isRotate1 = true;
        }
        if (0 > nx2 || nx2 >= 10 || 0 > ny2 || ny2 >= 10 || board[nx2][ny2] == 1) {
            dir2 = (dir2 + 1) % 4;
            isRotate2 = true;
        }
        if (!isRotate1) {
            x1 = nx1;
            y1 = ny1;
        }
        if (!isRotate2) {
            x2 = nx2;
            y2 = ny2;
        }
        if (x1 == x2 && y1 == y2) {
            return time;
        }
    }

    return 0;
}
```