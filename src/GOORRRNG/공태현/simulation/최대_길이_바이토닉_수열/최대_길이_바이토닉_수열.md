매개변수 nums에 길이가 n인 수열이 주어지면 이 수열의 연속부분수열 중 가장 긴 바이토닉 수열을 찾아 그 길이를 반환하는 프로그램을 작성하라.

만약, [1, 3, 2, 5, 7, 4, 2, 5, 1] 수열이 주어지면 이 수열의 연속 부분 수열 중 가장 긴 바이토닉 수열은 [2, 5, 7, 4, 2]이고, 답은 5다.

### 입출력 예

---

<img width="494" alt="스크린샷 2024-03-27 오후 4 34 00" src="https://github.com/runtime-zer0/goorrrng/assets/147473025/d3ea26b8-4648-466b-9fd2-8a9de3caf70e">

### 제한사항

---

- nums의 길이는 3 <= n <= 10,000
- 배열 nums의 원소는 자연수다.

### 문제 접근

---

해당 문제는 바이토닉 수열의 의미를 이해하면, 쉽게 풀수 있는 문제다.

먼저 바이토닉수열을 구성하는 봉우리 지점을 찾는다.

예를들어  1, 2, 3, 2, 1 처럼 수열이 주어진다면 봉우리 지점은 3이된다.

쉽게말해 주어진 수열을 순차 탐색하면서 nums[i - 1] < nums[i] 를 만족하고 nums[i] > nums[i + 1] 을 만족하는 i를 찾아서 리스트에 저장한다.

그리고 루프를 활용하여 리스트에 저장되어있는 인덱스를 기준으로 탐색을 진행한다.

탐색을 진행하는 방법은 아래와 같다.

1. **봉우리 인덱스를 기준으로 왼쪽 방향으로 탐색을 진행**할 lt 값을 순차적으로 감소시키면서 바이토닉 수열의 조건을 만족할동안 탐색을 진행
2. **봉우리 인덱스를 기준으로 오른쪽 방향으로 탐색을 진행**할 rt 값을 순차적으로 증가시키면서 바이토닉 수열의 조건을 만족할동안 탐색을 진행
3. **1, 2 과정은 독립된 과정**이며, 1, 2 과정에서 바이토닉수열을 만족하는 원소를 찾을때 마다 cnt 값을 증가
4. 하나의 봉우리를 기준으로 **탐색을 완료하고 이전에 저장되어있는 최대 바이토닉수열 길이값과 비교하여 최댓값을 계산**

네이버와 카카오에서 완전 동일하게 출제 되지는 않았지만 최대 바이토닉길이 값을 계산하는 문제가 출제된적있다. 비슷한 문제가 출제될수 있으므로 확실하게 이해하자.

### 체크포인트

---

- **봉우리(peek) 원소 우선 탐색**

    ```java
    문제에서 주어진 수열을 순차 탐색하면서 nums[i - 1] < nums[i] 를 만족하고 nums[i] > nums[i + 1] 을 만족하는 봉우리(peek) i를 찾아서 리스트에 저장
    ```

- **두개의 포인터를 활용하여 독립적으로 바이토닉 원소 탐색**

    ```java
    봉우리(peek) 원소를 기준으로 lt, rt 포인터를 활용하여 바이토닉수열을 만족하는 원소를 독립적으로 탐색 
    ```


---

위의 내용을 바탕으로 아래와 같이 풀것이다.

1. 봉우리 지점(peek)을 기준으로만 탐색을 진행하기 위해 주어진 수열에서 봉우리(peek) 인덱스를 탐색후 저장

    ```java
    // 봉우리(peek) 원소의 인덱스를 탐색
    for (int i = 1; i < n-1; i++) {
        if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {
            list.add(i);
        }
    }
    ```

2. 봉우리 지점부터 탐색을 시작하고 봉우리 인덱스를 바탕으로 lt, rt 생성후, 초기화

    ```java
    // 봉우리 인덱스 만을 기준으로 탐색 시작
    for (int idx : list) {
        int cnt = 1;
        int lt = idx;
        int rt = idx;
    ```

3. 봉우리(peek) 기준 왼쪽 방향으로 탐색을 진행하기 위해 lt가 0보다 크고 현재 lt 가 가리키고있는 원소가 lt - 1이 가리키는 원소보다 큰지 확인

   조건을 만족하는 바이토닉수열원소를 탐색하면서 바이토닉수열의 원소를 찾을때 마다 cnt값 1씩 증가

    ```java
    // 봉우리(peek) 기준 왼쪽 방향으로 탐색
    while (lt > 0 && nums[lt - 1] < nums[lt]) {
        // 크다면 바이토닉수열 원소를 찾은것이므로 cnt 1 증가
        cnt++;
        // 다음 탐색을 위해 lt값 1 감소
        lt--;
    }
    ```

4. 봉우리(peek) 기준 오른쪽 방향으로 탐색을 진행하기 위해, rt가 n-1 보다 크고 현재 rt가 가리키는 원소가 rt+1이 가리키고있는 원소보다 큰지 확인

   조건을 만족하는 바이토닉수열원소를 탐색하면서 바이토닉수열의 원소를 찾을때 마다 cnt값 1씩 증가

    ```java
    // 봉우리(peek) 기준 오른쪽 방향으로 탐색
    while (rt < n-1 && nums[rt] > nums[rt+1]) {
        // 크다면 바이토닉수열 원소를 찾은것이므로 cnt 1 증가
        cnt++;
        // 다음 탐색을 위해 rt값 1 증가
        rt++;
    }
    ```

5. 하나의 봉우리(peek) 위치를 기준으로 탐색이 종료되면 이전에 계산한 최대 바이토닉수열 길이 값과 현재 계산한 바이토닉 수열의 길이 값과 비교하여 최대 길이 값을 저장.

    ```java
    // 최대 길이값 계산
    answer = Math.max(answer, cnt);
    ```


### 코드

---

```java
static int solution(int[] nums) {
    int n = nums.length;
    int answer = Integer.MIN_VALUE;
    List<Integer> list = new ArrayList<>();

    // 봉우리(peek) 원소의 인덱스를 탐색
    for (int i = 1; i < n-1; i++) {
        if (nums[i - 1] < nums[i] && nums[i] > nums[i + 1]) {
            list.add(i);
        }
    }
    // 봉우리 인덱스 만을 기준으로 탐색 시작
    for (int idx : list) {
        int cnt = 1;
        int lt = idx;
        int rt = idx;
        // 봉우리(peek) 기준 왼쪽 방향으로 탐색
        // lt가 0보다 크고 현재 lt 가 가리키고있는 원소가 lt - 1이 가리키는 원소보다 큰지 확인
        while (lt > 0 && nums[lt - 1] < nums[lt]) {
            // 크다면 바이토닉수열 원소를 찾은것이므로 cnt 1 증가
            cnt++;
            // 다음 탐색을 위해 lt값 1 감소
            lt--;
        }
        // 봉우리(peek) 기준 오른쪽 방향으로 탐색
        // rt가 n-1 보다 크고 현재 rt가 가리키는 원소가 rt+1이 가리키고있는 원소보다 큰지 확인
        while (rt < n-1 && nums[rt] > nums[rt+1]) {
            // 크다면 바이토닉수열 원소를 찾은것이므로 cnt 1 증가
            cnt++;
            // 다음 탐색을 위해 rt값 1 증가
            rt++;
        }
        // 최대 길이값 계산
        answer = Math.max(answer, cnt);
    }

    return answer;
}
```